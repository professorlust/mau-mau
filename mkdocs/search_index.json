{
    "docs": [
        {
            "location": "/",
            "text": "Mau Mau\n\u00b6\n\n\n\n\nPlay is the highest form of research\n\n\n-- \nProbably not Albert Einstein\n\n\n\n\nThis project aims to be a learning tool, but this is a real application - not a toy example. The important difference to a \"real\" program is that the nasty details that usually screw with the nice and simple design and make the code grow tentacles and other cruft are kept at a minimum to enable you to \nexplore the code\n as a nice little completely non-linear story. It came to life in a non-linear fashion and should also be read that way.\n\n\nEmphasis is put on \npythonic\n ways to code and on using the power of the Open Source ecosystem.\n\n\nFeatures\n\u00b6\n\n\nThe game\n\u00b6\n\n\n\n\nComplete \nrules of Mau Mau\n\n\nTwo different \nstrategies\n:\n\n\nSimple random strategy for a computer player\n\n\nStrategy that adds interactivity so a human can play against the computer\n\n\n\n\n\n\n\n\nImplementation and tools\n\u00b6\n\n\n\n\nInstallable\n as \ncommand line tool\n\n\nFunctions\n to run multiple games and collect stats\n\n\nUse of \nmagic methods\n to create custom classes which behave like inbuilt data types\n\n\nLogging with stdlib \nlogging module\n\n\nFlexible \ncommand line interface\n (add new functions without adjusting code)\n\n\nAutomatic tests\n with py.test, tox and Travis CI\n\n\nStatic code analysis\n: flake8, \nQuantifiedCode\n, \npytest\n, Travis CI and Appveyor\n\n\nVersion handling from source control\n with \nsetuptools scm\n\n\nAutomatic generation and deployment of documentation with \nMkDocs\n\n\nDeveloper task automation with \ntox\n (run tests, build and deploy documentation)\n\n\nIncluded Linux and Windows development environments via \nvagrant\n.",
            "title": "Home"
        },
        {
            "location": "/#mau-mau",
            "text": "Play is the highest form of research  --  Probably not Albert Einstein   This project aims to be a learning tool, but this is a real application - not a toy example. The important difference to a \"real\" program is that the nasty details that usually screw with the nice and simple design and make the code grow tentacles and other cruft are kept at a minimum to enable you to  explore the code  as a nice little completely non-linear story. It came to life in a non-linear fashion and should also be read that way.  Emphasis is put on  pythonic  ways to code and on using the power of the Open Source ecosystem.",
            "title": "Mau Mau"
        },
        {
            "location": "/#features",
            "text": "",
            "title": "Features"
        },
        {
            "location": "/#the-game",
            "text": "Complete  rules of Mau Mau  Two different  strategies :  Simple random strategy for a computer player  Strategy that adds interactivity so a human can play against the computer",
            "title": "The game"
        },
        {
            "location": "/#implementation-and-tools",
            "text": "Installable  as  command line tool  Functions  to run multiple games and collect stats  Use of  magic methods  to create custom classes which behave like inbuilt data types  Logging with stdlib  logging module  Flexible  command line interface  (add new functions without adjusting code)  Automatic tests  with py.test, tox and Travis CI  Static code analysis : flake8,  QuantifiedCode ,  pytest , Travis CI and Appveyor  Version handling from source control  with  setuptools scm  Automatic generation and deployment of documentation with  MkDocs  Developer task automation with  tox  (run tests, build and deploy documentation)  Included Linux and Windows development environments via  vagrant .",
            "title": "Implementation and tools"
        },
        {
            "location": "/guide/installation/",
            "text": "Installation\n\u00b6\n\n\nPython 3\n (not 2)\n\u00b6\n\n\n\n\nShort version: Python 2.x is legacy, Python 3.x is the present and future of the language\n\n\n\n\n-- \nShould I use Python 2 or Python 3 for my development activity?\n\n\n... nuff said.\n\n\n\n\nNote\n\n\nIt might already be installed. Type \npython\n on the commandline and see if a Python \nREPL\n opens and which version it reports. If the standard python interpreter is still Python2 on your system, try typing \npython3\n instead and see if you are lucky. If not get it here: \nPython3\n.\n\n\n\n\n[In a virtualenv]\n\u00b6\n\n\n\n\nNote\n\n\nThe installation of this package in a virtualenv is is not necessary but recommended. It is worth learning to work with virtualenvs as early as possible anyway.\n\n\n\n\nYou should really install this in a \nvirtualenv\n. This should work out of the box. If not, you might be on Linux and are bitten by \nthis\n. \nsudo apt-get install python3-pip\n should solve the problem - otherwise have a look at the \npip documentation\n.\n\n\n$ python3 -m venv mau-mau-env\n\n\n\nActivation of virtualenvs is sadly still one of the things that is not os independent, so you will have to look \nhere\n how to do that in your os. The most common cases are:\n\n\n$ source mau-mau-env/bin/activate  # most linux shells\n$ mau-mau-env\\Scripts\\activate.bat  # Windows cmd.exe\n\n\n\nDeactivate with:\n\n\n$ deactivate\n\n\n\n... from Github\n\u00b6\n\n\nInstall the latest code directly from github by typing on the command line:\n\n\n$ pip install \"git+https://github.com/obestwalter/mau-mau.git#egg=mau-mau\"\n\n\n\nTo install a specific version just replace \nmaster\n with the version you want to install (e.g. \n1.1.0\n). The different versions can be seen in the \nrelease section\n of a Github project.\n\n\n... from .zip file\n\u00b6\n\n\nOn the \nreleases page\n you can download zip archives and install them by typing on the command line:\n\n\n$ pip install </path/to/downloaded/zip/archive>\n\n\n\n... from \nPyPI\n\u00b6\n\n\n\n\nThis is not implemented\n\n\nThis would mean uploading the package to the official Python Package Index (PyPI -- formerly known as the cheese shop -- documented \nhere\n) ... it's not hard to do but not necessary for a learning tool like this, so I just mention it here, because that is the official way for \"real\" software.\n\n\n\n\nIf \nmau-mau\n would be uploaded to PyPI, it could be installed by simply typing:\n\n\n$ pip install mau-mau",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#python-3-not-2",
            "text": "Short version: Python 2.x is legacy, Python 3.x is the present and future of the language   --  Should I use Python 2 or Python 3 for my development activity?  ... nuff said.   Note  It might already be installed. Type  python  on the commandline and see if a Python  REPL  opens and which version it reports. If the standard python interpreter is still Python2 on your system, try typing  python3  instead and see if you are lucky. If not get it here:  Python3 .",
            "title": "Python 3 (not 2)"
        },
        {
            "location": "/guide/installation/#in-a-virtualenv",
            "text": "Note  The installation of this package in a virtualenv is is not necessary but recommended. It is worth learning to work with virtualenvs as early as possible anyway.   You should really install this in a  virtualenv . This should work out of the box. If not, you might be on Linux and are bitten by  this .  sudo apt-get install python3-pip  should solve the problem - otherwise have a look at the  pip documentation .  $ python3 -m venv mau-mau-env  Activation of virtualenvs is sadly still one of the things that is not os independent, so you will have to look  here  how to do that in your os. The most common cases are:  $ source mau-mau-env/bin/activate  # most linux shells\n$ mau-mau-env\\Scripts\\activate.bat  # Windows cmd.exe  Deactivate with:  $ deactivate",
            "title": "[In a virtualenv]"
        },
        {
            "location": "/guide/installation/#from-github",
            "text": "Install the latest code directly from github by typing on the command line:  $ pip install \"git+https://github.com/obestwalter/mau-mau.git#egg=mau-mau\"  To install a specific version just replace  master  with the version you want to install (e.g.  1.1.0 ). The different versions can be seen in the  release section  of a Github project.",
            "title": "... from Github"
        },
        {
            "location": "/guide/installation/#from-zip-file",
            "text": "On the  releases page  you can download zip archives and install them by typing on the command line:  $ pip install </path/to/downloaded/zip/archive>",
            "title": "... from .zip file"
        },
        {
            "location": "/guide/installation/#from-pypi",
            "text": "This is not implemented  This would mean uploading the package to the official Python Package Index (PyPI -- formerly known as the cheese shop -- documented  here ) ... it's not hard to do but not necessary for a learning tool like this, so I just mention it here, because that is the official way for \"real\" software.   If  mau-mau  would be uploaded to PyPI, it could be installed by simply typing:  $ pip install mau-mau",
            "title": "... from PyPI"
        },
        {
            "location": "/guide/usage/",
            "text": "Usage\n\u00b6\n\n\nCommand line access\n\u00b6\n\n\nAfter installation you have an additional command in your virtualenv: \nmau-mau\n. The default behaviour if you call it without parameters is to simulate a simple game of Mau Mau between three computer players (and you can see the hands of all the players and every step of the game).\n\n\n\n\nmau-mau\n: Play single game with high verbosity settings in the logger\n\n\nmau-mau <stats.function>\n: e.g. \nmau-mau mean_turns\n - the argument will be passed to \nget_function_from_name\n that fetches a function object of the same name from \nstats.py\n and executes it. This is a very simple way to create a flexible command line interface that does not need to be changed if you create more statistics functions in \nstatistics.py\n. Adding a new function to \nstatistics.py\n will automatically make it accessible through the command line interface.\n\n\nmau-mau human\n ... or any other argument that does not map to a function in stats: play a game against the computer.\n\n\n\n\nRun a simple simulation\n\u00b6\n\n\n    $ cd </path/to/your/clone>\n    $ mau-mau\n\n\n\nThe output could be:\n\n\nroot                53  main             : play_simple_game() ...\nmau_mau.subjects    28  invite           : invite [Player('Player 1', Hand([])), Player('Player 2', Hand([])), Player('Player 3', Hand([]))] to: Table(None, None)\nmau_mau.subjects    100 draw             : Player 1 <- Card('10', '\u2663')\nmau_mau.subjects    100 draw             : Player 1 <- Card('8', '\u2663')\nmau_mau.subjects    100 draw             : Player 1 <- Card('Ace', '\u2663')\nmau_mau.subjects    100 draw             : Player 1 <- Card('Ace', '\u2660')\nmau_mau.subjects    100 draw             : Player 1 <- Card('9', '\u2665')\nmau_mau.subjects    100 draw             : Player 2 <- Card('8', '\u2665')\nmau_mau.subjects    100 draw             : Player 2 <- Card('7', '\u2663')\nmau_mau.subjects    100 draw             : Player 2 <- Card('Queen', '\u2665')\nmau_mau.subjects    100 draw             : Player 2 <- Card('7', '\u2660')\nmau_mau.subjects    100 draw             : Player 2 <- Card('8', '\u2666')\nmau_mau.subjects    100 draw             : Player 3 <- Card('10', '\u2665')\nmau_mau.subjects    100 draw             : Player 3 <- Card('9', '\u2666')\nmau_mau.subjects    100 draw             : Player 3 <- Card('Jack', '\u2660')\nmau_mau.subjects    100 draw             : Player 3 <- Card('Jack', '\u2663')\nmau_mau.subjects    100 draw             : Player 3 <- Card('King', '\u2665')\nmau_mau.play        28  setup_game       : Start new game: Game(Table(MauMau(5), [Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])), Player('Player 2', Hand([Card('8', '\u2665'), Card('7', '\u2663'), Card('Queen', '\u2665'), Card('7', '\u2660'), Card('8', '\u2666')])), Player('Player 3', Hand([Card('10', '\u2665'), Card('9', '\u2666'), Card('Jack', '\u2660'), Card('Jack', '\u2663'), Card('King', '\u2665')]))]))\nmau_mau.concepts    25  next_turn        : -------------------- turn 1 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Queen', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Queen', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('10', '\u2663')\n[--- SNIP ---]\nmau_mau.concepts    25  next_turn        : -------------------- turn 27 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 3', Hand([Card('King', '\u2665'), Card('Queen', '\u2666'), Card('9', '\u2660')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.strategy    65  _play            : nothing to play\nmau_mau.subjects    100 draw             : Player 3 <- Card('8', '\u2660')\nmau_mau.concepts    25  next_turn        : -------------------- turn 28 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 1', Hand([Card('Ace', '\u2660'), Card('King', '\u2660'), Card('7', '\u2665'), Card('King', '\u2666')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.strategy    65  _play            : nothing to play\nmau_mau.subjects    100 draw             : Player 1 <- Card('Queen', '\u2660')\nmau_mau.concepts    25  next_turn        : -------------------- turn 29 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 2', Hand([Card('King', '\u2663')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('King', '\u2663')\nroot                21  play_simple_game : And the winner is Player 2\n\n\n\nPlay against the computer\n\u00b6\n\n\nPlay interactive game (and know and see everything ...):\n\n\n$ mau-mau human\n\n\n\nThe output could be:\n\n\nroot                53  main             : play_interactive_game() ...\nmau_mau.subjects    28  invite           : invite [Player('Eric', Hand([])), Player('John', Hand([])), Player('human', Hand([]))] to: Table(None, None)\nmau_mau.subjects    100 draw             : Eric <- Card('Queen', '\u2660')\nmau_mau.subjects    100 draw             : Eric <- Card('10', '\u2660')\nmau_mau.subjects    100 draw             : Eric <- Card('Queen', '\u2663')\nmau_mau.subjects    100 draw             : Eric <- Card('8', '\u2666')\nmau_mau.subjects    100 draw             : Eric <- Card('7', '\u2660')\nmau_mau.subjects    100 draw             : John <- Card('9', '\u2660')\nmau_mau.subjects    100 draw             : John <- Card('Ace', '\u2660')\nmau_mau.subjects    100 draw             : John <- Card('10', '\u2666')\nmau_mau.subjects    100 draw             : John <- Card('Ace', '\u2663')\nmau_mau.subjects    100 draw             : John <- Card('8', '\u2665')\nmau_mau.subjects    100 draw             : human <- Card('Ace', '\u2666')\nmau_mau.subjects    100 draw             : human <- Card('7', '\u2666')\nmau_mau.subjects    100 draw             : human <- Card('King', '\u2665')\nmau_mau.subjects    100 draw             : human <- Card('9', '\u2666')\nmau_mau.subjects    100 draw             : human <- Card('King', '\u2660')\nmau_mau.play        28  setup_game       : Start new game: Game(Table(MauMau(5), [Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])), Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])), Player('human', Hand([Card('Ace', '\u2666'), Card('7', '\u2666'), Card('King', '\u2665'), Card('9', '\u2666'), Card('King', '\u2660')]))]))\nmau_mau.concepts    25  next_turn        : -------------------- turn 1 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Queen', '\u2663')\nmau_mau.concepts    25  next_turn        : -------------------- turn 2 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Queen', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Queen', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Ace', '\u2663')\n[---- SNIP ----]\nmau_mau.concepts    25  next_turn        : -------------------- turn 22 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('8', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Eric', Hand([Card('10', '\u2663'), Card('10', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule SkipNextPlayer on Card('8', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('10', '\u2665')\nmau_mau.concepts    25  next_turn        : -------------------- turn 23 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('10', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('John', Hand([Card('Ace', '\u2665'), Card('King', '\u2666'), Card('7', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('10', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Ace', '\u2665')\nmau_mau.concepts    25  next_turn        : -------------------- turn 24 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Ace', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('human', Hand([Card('King', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Ace', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nchoose card to play.\n1 -> Card('King', '\u2665') | 1\nmau_mau.subjects    103 put              : play Card('King', '\u2665')\nroot                27  play_interactive_game: And the winner is human\n\n\n\nCollect statistics\n\u00b6\n\n\n$ mau-mau mean_turns\n\n\n\nThe output could be:\n\n\nroot                42  main             : mean_turns() ...\nmau_mau.stats       35  _simulate_games  : players: 3; 1000 reps\nmau_mau.stats       12  mean_turns       : mean turns played: 34.097\n\n\n\nInput:\n\n\n$ mau-mau winner_distribution\n\n\n\nThe output could be:\n\n\nroot                52  main             : winner_distribution() ...\nmau_mau.stats       35  _simulate_games  : players: ('Eric', 'Terry', 'John'); 1000 reps\nmau_mau.stats       21  winner_distribution: winner distribution: {'Eric': 345, 'Terry': 327, 'John': 328}\n\n\n\nInput:\n\n\n$ mau-mau time_durations\n\n\n\nThe output could be:\n\n\nroot                52  main             : time_durations() ...\nmau_mau.stats       31  time_durations   : it takes 0.643 seconds to play 1000 games",
            "title": "Command line access"
        },
        {
            "location": "/guide/usage/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/guide/usage/#command-line-access",
            "text": "After installation you have an additional command in your virtualenv:  mau-mau . The default behaviour if you call it without parameters is to simulate a simple game of Mau Mau between three computer players (and you can see the hands of all the players and every step of the game).   mau-mau : Play single game with high verbosity settings in the logger  mau-mau <stats.function> : e.g.  mau-mau mean_turns  - the argument will be passed to  get_function_from_name  that fetches a function object of the same name from  stats.py  and executes it. This is a very simple way to create a flexible command line interface that does not need to be changed if you create more statistics functions in  statistics.py . Adding a new function to  statistics.py  will automatically make it accessible through the command line interface.  mau-mau human  ... or any other argument that does not map to a function in stats: play a game against the computer.",
            "title": "Command line access"
        },
        {
            "location": "/guide/usage/#run-a-simple-simulation",
            "text": "$ cd </path/to/your/clone>\n    $ mau-mau  The output could be:  root                53  main             : play_simple_game() ...\nmau_mau.subjects    28  invite           : invite [Player('Player 1', Hand([])), Player('Player 2', Hand([])), Player('Player 3', Hand([]))] to: Table(None, None)\nmau_mau.subjects    100 draw             : Player 1 <- Card('10', '\u2663')\nmau_mau.subjects    100 draw             : Player 1 <- Card('8', '\u2663')\nmau_mau.subjects    100 draw             : Player 1 <- Card('Ace', '\u2663')\nmau_mau.subjects    100 draw             : Player 1 <- Card('Ace', '\u2660')\nmau_mau.subjects    100 draw             : Player 1 <- Card('9', '\u2665')\nmau_mau.subjects    100 draw             : Player 2 <- Card('8', '\u2665')\nmau_mau.subjects    100 draw             : Player 2 <- Card('7', '\u2663')\nmau_mau.subjects    100 draw             : Player 2 <- Card('Queen', '\u2665')\nmau_mau.subjects    100 draw             : Player 2 <- Card('7', '\u2660')\nmau_mau.subjects    100 draw             : Player 2 <- Card('8', '\u2666')\nmau_mau.subjects    100 draw             : Player 3 <- Card('10', '\u2665')\nmau_mau.subjects    100 draw             : Player 3 <- Card('9', '\u2666')\nmau_mau.subjects    100 draw             : Player 3 <- Card('Jack', '\u2660')\nmau_mau.subjects    100 draw             : Player 3 <- Card('Jack', '\u2663')\nmau_mau.subjects    100 draw             : Player 3 <- Card('King', '\u2665')\nmau_mau.play        28  setup_game       : Start new game: Game(Table(MauMau(5), [Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])), Player('Player 2', Hand([Card('8', '\u2665'), Card('7', '\u2663'), Card('Queen', '\u2665'), Card('7', '\u2660'), Card('8', '\u2666')])), Player('Player 3', Hand([Card('10', '\u2665'), Card('9', '\u2666'), Card('Jack', '\u2660'), Card('Jack', '\u2663'), Card('King', '\u2665')]))]))\nmau_mau.concepts    25  next_turn        : -------------------- turn 1 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Queen', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Queen', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('10', '\u2663')\n[--- SNIP ---]\nmau_mau.concepts    25  next_turn        : -------------------- turn 27 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 3', Hand([Card('King', '\u2665'), Card('Queen', '\u2666'), Card('9', '\u2660')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.strategy    65  _play            : nothing to play\nmau_mau.subjects    100 draw             : Player 3 <- Card('8', '\u2660')\nmau_mau.concepts    25  next_turn        : -------------------- turn 28 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 1', Hand([Card('Ace', '\u2660'), Card('King', '\u2660'), Card('7', '\u2665'), Card('King', '\u2666')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.strategy    65  _play            : nothing to play\nmau_mau.subjects    100 draw             : Player 1 <- Card('Queen', '\u2660')\nmau_mau.concepts    25  next_turn        : -------------------- turn 29 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 2', Hand([Card('King', '\u2663')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('King', '\u2663')\nroot                21  play_simple_game : And the winner is Player 2",
            "title": "Run a simple simulation"
        },
        {
            "location": "/guide/usage/#play-against-the-computer",
            "text": "Play interactive game (and know and see everything ...):  $ mau-mau human  The output could be:  root                53  main             : play_interactive_game() ...\nmau_mau.subjects    28  invite           : invite [Player('Eric', Hand([])), Player('John', Hand([])), Player('human', Hand([]))] to: Table(None, None)\nmau_mau.subjects    100 draw             : Eric <- Card('Queen', '\u2660')\nmau_mau.subjects    100 draw             : Eric <- Card('10', '\u2660')\nmau_mau.subjects    100 draw             : Eric <- Card('Queen', '\u2663')\nmau_mau.subjects    100 draw             : Eric <- Card('8', '\u2666')\nmau_mau.subjects    100 draw             : Eric <- Card('7', '\u2660')\nmau_mau.subjects    100 draw             : John <- Card('9', '\u2660')\nmau_mau.subjects    100 draw             : John <- Card('Ace', '\u2660')\nmau_mau.subjects    100 draw             : John <- Card('10', '\u2666')\nmau_mau.subjects    100 draw             : John <- Card('Ace', '\u2663')\nmau_mau.subjects    100 draw             : John <- Card('8', '\u2665')\nmau_mau.subjects    100 draw             : human <- Card('Ace', '\u2666')\nmau_mau.subjects    100 draw             : human <- Card('7', '\u2666')\nmau_mau.subjects    100 draw             : human <- Card('King', '\u2665')\nmau_mau.subjects    100 draw             : human <- Card('9', '\u2666')\nmau_mau.subjects    100 draw             : human <- Card('King', '\u2660')\nmau_mau.play        28  setup_game       : Start new game: Game(Table(MauMau(5), [Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])), Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])), Player('human', Hand([Card('Ace', '\u2666'), Card('7', '\u2666'), Card('King', '\u2665'), Card('9', '\u2666'), Card('King', '\u2660')]))]))\nmau_mau.concepts    25  next_turn        : -------------------- turn 1 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Queen', '\u2663')\nmau_mau.concepts    25  next_turn        : -------------------- turn 2 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Queen', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Queen', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Ace', '\u2663')\n[---- SNIP ----]\nmau_mau.concepts    25  next_turn        : -------------------- turn 22 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('8', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Eric', Hand([Card('10', '\u2663'), Card('10', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule SkipNextPlayer on Card('8', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('10', '\u2665')\nmau_mau.concepts    25  next_turn        : -------------------- turn 23 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('10', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('John', Hand([Card('Ace', '\u2665'), Card('King', '\u2666'), Card('7', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('10', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Ace', '\u2665')\nmau_mau.concepts    25  next_turn        : -------------------- turn 24 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Ace', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('human', Hand([Card('King', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Ace', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nchoose card to play.\n1 -> Card('King', '\u2665') | 1\nmau_mau.subjects    103 put              : play Card('King', '\u2665')\nroot                27  play_interactive_game: And the winner is human",
            "title": "Play against the computer"
        },
        {
            "location": "/guide/usage/#collect-statistics",
            "text": "$ mau-mau mean_turns  The output could be:  root                42  main             : mean_turns() ...\nmau_mau.stats       35  _simulate_games  : players: 3; 1000 reps\nmau_mau.stats       12  mean_turns       : mean turns played: 34.097  Input:  $ mau-mau winner_distribution  The output could be:  root                52  main             : winner_distribution() ...\nmau_mau.stats       35  _simulate_games  : players: ('Eric', 'Terry', 'John'); 1000 reps\nmau_mau.stats       21  winner_distribution: winner distribution: {'Eric': 345, 'Terry': 327, 'John': 328}  Input:  $ mau-mau time_durations  The output could be:  root                52  main             : time_durations() ...\nmau_mau.stats       31  time_durations   : it takes 0.643 seconds to play 1000 games",
            "title": "Collect statistics"
        },
        {
            "location": "/guide/rules/",
            "text": "Rules\n\u00b6\n\n\nBasics\n\u00b6\n\n\n\n\nThe game is played with a regular deck of playing cards. The players are dealt each a hand of cards (usually 5). The rest are placed face down as the drawing stack. At the beginning of the game the topmost card is revealed, then the players each get a turn to play cards.\n\n\nOne can play a card if it corresponds to the suit or value of the open card. E.g. on a 10 of spades, only other spades can be played or other 10s. If a player is not able to, they draw one card from the stack. If he can play this card, he may do so, otherwise he keeps the drawn card and passes his turn. If the drawing stack is empty, the playing stack (except for the topmost card) is shuffled and turned over to serve as new drawing stack.\n\n\n-- \nWikipedia - Mau Mau\n\n\n\n\nCommon additions\n\u00b6\n\n\nIn addition, the three most common rules are implemented:\n\n\n\n\nIf an eight is played, the next player is skipped\n\n\nIf a seven is played, the next player has to draw two cards. The next player can put another seven down and instead the following player will have to draw four cards (and so on).\n\n\nA Jack can can be put on anything and the player who played it can ask for a different suite to be played",
            "title": "Rules of Mau Mau"
        },
        {
            "location": "/guide/rules/#rules",
            "text": "",
            "title": "Rules"
        },
        {
            "location": "/guide/rules/#basics",
            "text": "The game is played with a regular deck of playing cards. The players are dealt each a hand of cards (usually 5). The rest are placed face down as the drawing stack. At the beginning of the game the topmost card is revealed, then the players each get a turn to play cards.  One can play a card if it corresponds to the suit or value of the open card. E.g. on a 10 of spades, only other spades can be played or other 10s. If a player is not able to, they draw one card from the stack. If he can play this card, he may do so, otherwise he keeps the drawn card and passes his turn. If the drawing stack is empty, the playing stack (except for the topmost card) is shuffled and turned over to serve as new drawing stack.  --  Wikipedia - Mau Mau",
            "title": "Basics"
        },
        {
            "location": "/guide/rules/#common-additions",
            "text": "In addition, the three most common rules are implemented:   If an eight is played, the next player is skipped  If a seven is played, the next player has to draw two cards. The next player can put another seven down and instead the following player will have to draw four cards (and so on).  A Jack can can be put on anything and the player who played it can ask for a different suite to be played",
            "title": "Common additions"
        },
        {
            "location": "/implementation/ooommm/",
            "text": "OOOMMM\n\u00b6\n\n\nObvious Object Oriented Mau Mau Modelling\n\u00b6\n\n\nSwitching into egghead mode, you could say that a game of Mau Mau can be modelled as a series of interactions between actors with adjustable attributes and behaviours modifying their own attributes and initiating reactions and attribute changes in other actors. If you call the actors objects and the behaviour methods, you have a basic description of object oriented programming.\n\n\n\n\nObject-oriented design is, in its simplest form, based on a seemingly elementary idea. Computing systems perform certain actions on certain objects; to obtain flexible and reusable systems, it is better to base the structure of software on the objects than on the actions. \n\n\n-- \nBertrand Meyer - Object-Oriented Software Construction\n \n\n\n\n\nThat's all very ... abstract, isn't it? Yes it is! Meyer goes on:\n\n\n\n\nOnce you have said this, you have not really provided a definition, but rather posed a set of problems: What precisely is an object? How do you find and describe the objects? How should programs manipulate objects? What are the possible relations between objects? How does one explore the commonalities that may exist between various kinds of objects? How do these ideas relate to classical software engineering concerns such as correctness, ease of use, efficiency?\n\n\n\n\nWhat does that tell us? OO is just one of many ways of thinking about the problems you are trying to solve with software. Sometimes that way of thinking matches well with the problem you are trying to solve. There are also a lot of possibly very different answers to the questions posed by Meyer and they manifest in very different approaches to the implementation of OO in different programming languages.\n\n\nHigh level view\n\u00b6\n\n\nOne koan in the \nZen of Python\n says: \"If the implementation is easy to explain, it may be a good idea\". Let's put this to the test and explain the implementation of our Mau Mau program by simply describing the conditions and rules of the game using a rough approximation of the programs' terminology and see if the objects and their interactions make the implementation look obvious. \n\n\n\n\nThe image shows all the important elements of the simulation.\n\n\n\n\nNote\n\n\nObjects used in the program are marked \nlike this\n, functions that describe (inter)actions are marked like \nthis\n). \n\n\n\n\nThe game comprises two phases. We could call them \"setup\" and \"play\". \n\n\nSetup:\n The \nplayers\n are \ninvited\n to a \ngame\n at the \ntable\n. A \ndeck\n of \ncards\n is \nshuffled\n. The same amount of cards is \ndealt\n to the \nplayers\n to form their \nhand\n. One \ncard\n - the \nupcard\n - is \ndrawn\n from the \nstock\n and placed face up on the \ntable\n. The remaining cards are \npiled\n face down on the \ntable\n and form the \nstock\n. Now all is in place to \nplay\n the \ngame\n. \n\n\nPlay:\n The \nplayers\n play in \nturns\n. They choose a \ncard\n that is \nplayable\n with the \nupcard\n according to the rules (same \nsuit\n or same \nvalue\n and \nspecial rules\n) and place it on the \ntable\n. The played \ncard\n is the new  \nupcard\n and the old \nupcard\n is now part of the \nwaste\n. Now the next \nplayer\n is up. If a player can't find a \ncard\n to play, they have to draw one from the \nstock\n and the next \nplayer\n is up. If the \nstock\n \nis empty\n, the \nwaste\n \ncards\n are \nshuffled\n to form the new \nstock\n. The game is over and the \nwinner\n is found as soon as one \nplayer\n plays the last card of their \nhand\n.\n\n\nEasy enough to explain. This description of the rules and the gameplay can double already as a high level explanation of the implementation. It can also be read as an abstract story about a game, where the concrete story would be the description of an actual game. The program code can be viewed as story shape or abstract plot, with different executions of it as concrete stories. If you have no idea what I mean just watch \nKurt Vonneguts short talk about the shape of stories\n and transfer your insights into thinking about abstract program code and its concrete execution :)\n\n\nThe modelling problem we have here is ideal for creating custom data structures (which classes are), so we will model the game flow using \ncustom Python classes\n that interact in the way described above.",
            "title": "OOOMMM"
        },
        {
            "location": "/implementation/ooommm/#ooommm",
            "text": "",
            "title": "OOOMMM"
        },
        {
            "location": "/implementation/ooommm/#obvious-object-oriented-mau-mau-modelling",
            "text": "Switching into egghead mode, you could say that a game of Mau Mau can be modelled as a series of interactions between actors with adjustable attributes and behaviours modifying their own attributes and initiating reactions and attribute changes in other actors. If you call the actors objects and the behaviour methods, you have a basic description of object oriented programming.   Object-oriented design is, in its simplest form, based on a seemingly elementary idea. Computing systems perform certain actions on certain objects; to obtain flexible and reusable systems, it is better to base the structure of software on the objects than on the actions.   --  Bertrand Meyer - Object-Oriented Software Construction     That's all very ... abstract, isn't it? Yes it is! Meyer goes on:   Once you have said this, you have not really provided a definition, but rather posed a set of problems: What precisely is an object? How do you find and describe the objects? How should programs manipulate objects? What are the possible relations between objects? How does one explore the commonalities that may exist between various kinds of objects? How do these ideas relate to classical software engineering concerns such as correctness, ease of use, efficiency?   What does that tell us? OO is just one of many ways of thinking about the problems you are trying to solve with software. Sometimes that way of thinking matches well with the problem you are trying to solve. There are also a lot of possibly very different answers to the questions posed by Meyer and they manifest in very different approaches to the implementation of OO in different programming languages.",
            "title": "Obvious Object Oriented Mau Mau Modelling"
        },
        {
            "location": "/implementation/ooommm/#high-level-view",
            "text": "One koan in the  Zen of Python  says: \"If the implementation is easy to explain, it may be a good idea\". Let's put this to the test and explain the implementation of our Mau Mau program by simply describing the conditions and rules of the game using a rough approximation of the programs' terminology and see if the objects and their interactions make the implementation look obvious.    The image shows all the important elements of the simulation.   Note  Objects used in the program are marked  like this , functions that describe (inter)actions are marked like  this ).    The game comprises two phases. We could call them \"setup\" and \"play\".   Setup:  The  players  are  invited  to a  game  at the  table . A  deck  of  cards  is  shuffled . The same amount of cards is  dealt  to the  players  to form their  hand . One  card  - the  upcard  - is  drawn  from the  stock  and placed face up on the  table . The remaining cards are  piled  face down on the  table  and form the  stock . Now all is in place to  play  the  game .   Play:  The  players  play in  turns . They choose a  card  that is  playable  with the  upcard  according to the rules (same  suit  or same  value  and  special rules ) and place it on the  table . The played  card  is the new   upcard  and the old  upcard  is now part of the  waste . Now the next  player  is up. If a player can't find a  card  to play, they have to draw one from the  stock  and the next  player  is up. If the  stock   is empty , the  waste   cards  are  shuffled  to form the new  stock . The game is over and the  winner  is found as soon as one  player  plays the last card of their  hand .  Easy enough to explain. This description of the rules and the gameplay can double already as a high level explanation of the implementation. It can also be read as an abstract story about a game, where the concrete story would be the description of an actual game. The program code can be viewed as story shape or abstract plot, with different executions of it as concrete stories. If you have no idea what I mean just watch  Kurt Vonneguts short talk about the shape of stories  and transfer your insights into thinking about abstract program code and its concrete execution :)  The modelling problem we have here is ideal for creating custom data structures (which classes are), so we will model the game flow using  custom Python classes  that interact in the way described above.",
            "title": "High level view"
        },
        {
            "location": "/implementation/remarks/",
            "text": "Remarks\n\u00b6\n\n\nSignificant whitespace\n\u00b6\n\n\nPython is a language where space matters ... meaning  units of code (blocks, function bodies, etc.) are delimited by a colon (\n:\n) and indentation (4 spaces by convention) of all the following lines that belong to that block. A good editor that is language aware will help with that. It \nindents\n the code automatically after ending a line with a colon. It also lets you indent and dedent entire blocks of code that are marked by pressing the \nTab\n key and \noutdents\n them when pressing \nShift + Tab\n. \n\n\nSee also: \ncode layout\n in PEP8.\n\n\nExample:\n\n\ndef my_super_function():\n    print(\"I am indented with 4 spaces.\")\n    print(\"Me too! We both belong to the function!\")\nprint(\"I am not inside the function block anymore :(\")\n\nfor currentElement in range(5):\n    print(currentElement)\n    print(\"I also belong to the loop block\")\nprint(\"I don't belong to the loop block anymore\")\n\n\n\n\nEverything\n is an object\n\u00b6\n\n\nEverything. Even functions, classes, modules and files. Everything.\n\n\nIn this \nPython Online Tutor example\n you can see how really, really everything in a running Python program is an object.\n\n\nPassing by assignment\n\u00b6\n\n\n\n\nRemember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there\u2019s no alias between an argument name in the caller and callee, and so no call-by-reference per se.\n\n\n-- \nHow do I write a function with output parameters (call by reference)?\n\n\n\n\nThe way passing data to functions work in Python is \nquite specific\n, so it is important that you are aware of it and understand it. Walk through this example in the \ntutor\n to visualise what is really happening when you pass mutable objects into functions and e.g. append elements to a list object that was passed into a function. In the example it is a list but this holds true for any object that contains references to other objects.\n\n\nChanging the state of an object that is not returned explicitly is called a \nside effect\n. Purists of certain programming paradigms would tell you that this style is messy and error prone. I won't argue with them, because I might lose. For now that's how we do it here, because than you really understand how it works. Real world programs have lots of side effects anyway so better just get used to it :) The discussion around when and how to use side effects is a huge topic. For now I just want to make you aware that some of our functions and methods have side effects, meaning that not all changes to the state of the program are communicated purely by returning values. BTW: raising exceptions are also considered side effects and they are used a lot in Python.\n\n\nMagic methods (protocols)\n\u00b6\n\n\nThose \n__something__()\n thingies might look scary for the uninitiated, but you will love them, once you have grasped the idea. These methods are a way to use the internal language mechanics of Python for your own classes. They make up an important part of the Python superpowers and it's never too early to learn about them (you should at least know that they exist and that they have special meaning). Some of them are used in the model classes to create pythonic behaviour of the objects (e.g. make them iterable and comparable) and good representations.\n\n\nObject representation (\n__repr__\n)\n\u00b6\n\n\n\n\nIf at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value\n\n\n-- \nPython docs\n\n\n\n\nIn this simple simulation this is actually possible for all objects, so why not do it? This makes it possible to copy object representations from the output and recreate them in the REPL to experiment with them. If done correctly, this also works when using inheritance (see \nStock\n and \nWaste\n).\n\n\nThis could also be useful: \nreprlib helps making better representations\n.\n\n\nMake your own objects behave like built in data types\n\u00b6\n\n\n\n\nLet an object have a \nlength (\n__len__\n)\n and a concept of being \nTrue\n or \nFalse\n depending on having a length > 0 or not.\n\n\nMake an object \niterable (\n__iter__\n)\n.\n\n\n\n\nOther uses of special object attributes\n\u00b6\n\n\nAll objects have a \nname (\n__name__\n)\n\n\nThe name attribute of module objects are set dynamically depending on the context in which the module is loaded. If the module is run like a script it has a different name than when it is imported by another module. The names of modules are used for two purposes in this program:\n\n\n\n\nSet the name of the logger object to get information from where the log was written\n\n\nIf a module is started directly it has the special name \n__main__\n - this can be used to only execute certain code if it is meant to behave like a script (as opposed to being imported as a module). This is the \ncanonic way\n to do this. \n\n\n\n\nMore resources about magic methods\n\n\n\n\nPython docs\n\n\nA Guide to Python's Magic Methods\n (original site went down sadly)\n\n\n\n\nAssertions\n\u00b6\n\n\n\n\nWhat can be asserted without evidence can be dismissed without evidence.\n\n\n-- Christopher Hitchens\n\n\n\n\nTo assert something means \"to state or express positively\". Assertions are regarded as important enough in Python that \nassert\n is a statement\n (since Python 3 even \nprint\n is not important enough to be a statement). \nassert\n evaluates an expression and raises an \nAssertionError\n if the result of the evaluation is \nFalse\n (with a customizable message to provide more information about the problem). This can be a very simple check like making sure that an object is \ntruthy\n if evaluated as \nbool\n. \n\n\ndef spam(someObject):\n    assert someObject, \"Hey! %s is not what I want!\" % (someObject)\n    print(someObject)\n\nspam([1, 2])\nspam([])\n\n\n\n\nThe assert in the \nspam\n function makes sure that the argument passed evaluates to \nTrue\n before moving on. The first call is o.k. but the second raises the exception and prints the message as part of the traceback.\n\n\nThis is a good way to make sure that your program crashes early if the preconditions are not what you expect them. It's like making sure there is a chair there before you sit down. Used with good measure this can safe you a lot of trouble - finding the good measure for usage of the assert statement in your code is an art and not a science.\n\n\nLook for uses of the assert statement in the code to get an idea how it might be used.\n\n\nLogging\n\u00b6\n\n\nPython has an easy-to-use and convenient \nlogging module\n included. There is no reason why beginners shouldn't learn to use that right away. This is better than cluttering the code with calls to \nprint\n. With logging you have the possibility to use different \nlog levels\n and adjust the output when debugging problems. You can set the level to \nlogging.DEBUG\n to see the full story or even \ndisable\n it when running thousands of simulations, where logging would slow the program down.\n\n\nWe use a \nsimple format\n and the \nconvenience function\n to initialise the logger to write to the terminal with a certain level.",
            "title": "Remarks"
        },
        {
            "location": "/implementation/remarks/#remarks",
            "text": "",
            "title": "Remarks"
        },
        {
            "location": "/implementation/remarks/#significant-whitespace",
            "text": "Python is a language where space matters ... meaning  units of code (blocks, function bodies, etc.) are delimited by a colon ( : ) and indentation (4 spaces by convention) of all the following lines that belong to that block. A good editor that is language aware will help with that. It  indents  the code automatically after ending a line with a colon. It also lets you indent and dedent entire blocks of code that are marked by pressing the  Tab  key and  outdents  them when pressing  Shift + Tab .   See also:  code layout  in PEP8.  Example:  def my_super_function():\n    print(\"I am indented with 4 spaces.\")\n    print(\"Me too! We both belong to the function!\")\nprint(\"I am not inside the function block anymore :(\")\n\nfor currentElement in range(5):\n    print(currentElement)\n    print(\"I also belong to the loop block\")\nprint(\"I don't belong to the loop block anymore\")",
            "title": "Significant whitespace"
        },
        {
            "location": "/implementation/remarks/#everything-is-an-object",
            "text": "Everything. Even functions, classes, modules and files. Everything.  In this  Python Online Tutor example  you can see how really, really everything in a running Python program is an object.",
            "title": "Everything is an object"
        },
        {
            "location": "/implementation/remarks/#passing-by-assignment",
            "text": "Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there\u2019s no alias between an argument name in the caller and callee, and so no call-by-reference per se.  --  How do I write a function with output parameters (call by reference)?   The way passing data to functions work in Python is  quite specific , so it is important that you are aware of it and understand it. Walk through this example in the  tutor  to visualise what is really happening when you pass mutable objects into functions and e.g. append elements to a list object that was passed into a function. In the example it is a list but this holds true for any object that contains references to other objects.  Changing the state of an object that is not returned explicitly is called a  side effect . Purists of certain programming paradigms would tell you that this style is messy and error prone. I won't argue with them, because I might lose. For now that's how we do it here, because than you really understand how it works. Real world programs have lots of side effects anyway so better just get used to it :) The discussion around when and how to use side effects is a huge topic. For now I just want to make you aware that some of our functions and methods have side effects, meaning that not all changes to the state of the program are communicated purely by returning values. BTW: raising exceptions are also considered side effects and they are used a lot in Python.",
            "title": "Passing by assignment"
        },
        {
            "location": "/implementation/remarks/#magic-methods-protocols",
            "text": "Those  __something__()  thingies might look scary for the uninitiated, but you will love them, once you have grasped the idea. These methods are a way to use the internal language mechanics of Python for your own classes. They make up an important part of the Python superpowers and it's never too early to learn about them (you should at least know that they exist and that they have special meaning). Some of them are used in the model classes to create pythonic behaviour of the objects (e.g. make them iterable and comparable) and good representations.",
            "title": "Magic methods (protocols)"
        },
        {
            "location": "/implementation/remarks/#object-representation-__repr__",
            "text": "If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value  --  Python docs   In this simple simulation this is actually possible for all objects, so why not do it? This makes it possible to copy object representations from the output and recreate them in the REPL to experiment with them. If done correctly, this also works when using inheritance (see  Stock  and  Waste ).  This could also be useful:  reprlib helps making better representations .",
            "title": "Object representation (__repr__)"
        },
        {
            "location": "/implementation/remarks/#make-your-own-objects-behave-like-built-in-data-types",
            "text": "Let an object have a  length ( __len__ )  and a concept of being  True  or  False  depending on having a length > 0 or not.  Make an object  iterable ( __iter__ ) .",
            "title": "Make your own objects behave like built in data types"
        },
        {
            "location": "/implementation/remarks/#other-uses-of-special-object-attributes",
            "text": "All objects have a  name ( __name__ )  The name attribute of module objects are set dynamically depending on the context in which the module is loaded. If the module is run like a script it has a different name than when it is imported by another module. The names of modules are used for two purposes in this program:   Set the name of the logger object to get information from where the log was written  If a module is started directly it has the special name  __main__  - this can be used to only execute certain code if it is meant to behave like a script (as opposed to being imported as a module). This is the  canonic way  to do this.    More resources about magic methods   Python docs  A Guide to Python's Magic Methods  (original site went down sadly)",
            "title": "Other uses of special object attributes"
        },
        {
            "location": "/implementation/remarks/#assertions",
            "text": "What can be asserted without evidence can be dismissed without evidence.  -- Christopher Hitchens   To assert something means \"to state or express positively\". Assertions are regarded as important enough in Python that  assert  is a statement  (since Python 3 even  print  is not important enough to be a statement).  assert  evaluates an expression and raises an  AssertionError  if the result of the evaluation is  False  (with a customizable message to provide more information about the problem). This can be a very simple check like making sure that an object is  truthy  if evaluated as  bool .   def spam(someObject):\n    assert someObject, \"Hey! %s is not what I want!\" % (someObject)\n    print(someObject)\n\nspam([1, 2])\nspam([])  The assert in the  spam  function makes sure that the argument passed evaluates to  True  before moving on. The first call is o.k. but the second raises the exception and prints the message as part of the traceback.  This is a good way to make sure that your program crashes early if the preconditions are not what you expect them. It's like making sure there is a chair there before you sit down. Used with good measure this can safe you a lot of trouble - finding the good measure for usage of the assert statement in your code is an art and not a science.  Look for uses of the assert statement in the code to get an idea how it might be used.",
            "title": "Assertions"
        },
        {
            "location": "/implementation/remarks/#logging",
            "text": "Python has an easy-to-use and convenient  logging module  included. There is no reason why beginners shouldn't learn to use that right away. This is better than cluttering the code with calls to  print . With logging you have the possibility to use different  log levels  and adjust the output when debugging problems. You can set the level to  logging.DEBUG  to see the full story or even  disable  it when running thousands of simulations, where logging would slow the program down.  We use a  simple format  and the  convenience function  to initialise the logger to write to the terminal with a certain level.",
            "title": "Logging"
        },
        {
            "location": "/implementation/explore/",
            "text": "Explore the repository\n\u00b6\n\n\nTo explore the code repository it is best if you install the \nsources as editable\n. This means you can use the application as if it were installed normally but you can change the code and experiment.\n\n\nplay.py\n\u00b6\n\n\n\n\nStart exploring here\n\n\n\n\nThe overall plot of the Mau Mau story can be found here. This is the entry point for starting to explore the actual application. It is written in an \nimperative\n way (like a series of commands given to the computer). The code looks like a series of instructions which are to be carried out in a top down order, descending into the functions being called. The order can be influenced by loops (\nfor ... in\n or \nwhile\n) and conditioned branches (\nif ... then ... else\n). These are the basic control flow constructs Python has. There are a few more, but not many.\n\n\nBehold! The whole program in 6 lines!\n\n\ndef play_game(gameRules, playerSeed):\n    game = setup_game(gameRules, playerSeed)\n    while not game.over:\n        player = game.next_turn()\n        player.play(game.table)\n    return game\n\n\n\n\nThis is the meat of the simulation. Here is where all the magic happens. if you call this function a game of Mau Mau will be simulated and a winner is determined. \n6 lines of code\n including the function header and the return statement. You now have read the whole plot of the fascinating Mau Mau story. If you want to understand more, you can start digging deeper and visit the definitions of the \nfunctions\n and \nclasses\n used in the \nplay_game\n function. Just start to explore the code and how the objects interact in whatever non-linear way you might prefer. This gives you an idea of how a simulation of a simple turn based card game can be implemented as a program.\n\n\nModules defining the classes\n\u00b6\n\n\nThese look pretty different from \ngame.py\n and they are. Here is where the object oriented part of the story kicks in. If \ngame.py\n contains the plot, these modules contain the descriptions of the actors and props of the story. They describe the relevant part of the virtual universe that is created to run the simulation. It contains custom data structures (a.k.a. classes) to model the problem of simulating Mau Mau. You should be able to read through the classes and get an idea of what elements are needed to simulate a card game and how they might interact.\n\n\nconcepts.py\n\u00b6\n\n\nClasses that stand conceptually above the objects and subjects.\n\n\nobjects.py\n and \nsubjects.py\n\u00b6\n\n\nI know .. in Python everything is an object, so this would be meaningless. This is also not \nsubject oriented programming\n. These are just good terms for what those classes describe in the context of the program: there are objects in the game which are manipulated by the subjects.\n\n\nrules.py\n\u00b6\n\n\nThis contains the classes that implement the rules of Mau Mau. Start reading with the \nMauMau\n class and see if you can figure out how it works. There is always one concrete rule active on the table that is valid for the currently played round. Sometimes information gets transferred from one rule to the next (e.g. if a 7 was put on a 7, the number of draws have to accumulate).\n\n\nstrategies.py\n: How to play\n\u00b6\n\n\nClasses that implement different player behaviours.\n\n\n\n\nNote\n\n\nA player has a strategy, but the player also attaches it to the active rule, so that it can be queried for the wanted suit if a Jack is on the table.\n\n\n\n\nBasicStrategy\n\u00b6\n\n\nPlayer plays according to the rules and always chooses random antidotes if they have any (e.g. 7 on 7 to prevent having to draw) or normal cards. If playing a Jack it always asks for the suit it has the most of.\n\n\nThis can be extended upon to implement \"real\" strategies.\n\n\nHumanStrategy\n\u00b6\n\n\nMainly to show that the existing design makes it very easy to even add interactivity to let a human play against a computer (\nmau-mau human\n).\n\n\nThe impact of this is very likely to be zero on a planetary basis, as this is just a learning tool, but in general one should be very wary of implementing something just because it's easy:\n\n\n\n\nI call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\n\n\n-- Tony Hoare\n\n\n\n\n... you have been warned.\n\n\nstatistics.py\n: Create statistics\n\u00b6\n\n\nContains functions to run the game simulations and collect statistics. See \nusage examples\n\n\ncli.py\n: Command line access\n\u00b6\n\n\nThis contains the code for the command line interface. Its function \nmain\n is configured in \nsetup.py\n \nentry_points\n to act like a program called \nmau-mau\n that is accessible where the package is installed.\n\n\nPeripherals\n\u00b6\n\n\n\n\nNote\n\n\nThese files are not part of the actual software but are still vital for helping with development, installation, testing, etc. -- this makes all that tedious stuff you need when writing software less ... tedious.\n\n\n\n\nsetup.py\n: Make program installable\n\u00b6\n\n\nThis module is what is being called, when the package is installed via pip or with \npython3 setup.py\n. This is the standard way of doing it in the Python ecosystem and it is documented \nhere\n.\n\n\ntox.ini\n: Developer task automation\n\u00b6\n\n\nThis \nINI\n file configures tasks that can run with the tox commands. The primary goal of tox is to automate testing and act as a frontend for CI, but it can be used for automating other developer tasks as well. See also \nthe developer documentation\n for this tox.ini.\n\n\n.travis.yml\n and \nappveyor.yml\n: CI for different versions and osses\n\u00b6\n\n\nSee \ndocumentation about CI\n\n\nmkdocs.yml\n: Documentation configuration\n\u00b6\n\n\nSee the \ndocumentation for the documentation\n (I'm not kidding ...).\n\n\nVagrantfile\n\u00b6\n\n\nTo start a VirtualBox with Linux or Windows prepared for development.",
            "title": "Explore the code"
        },
        {
            "location": "/implementation/explore/#explore-the-repository",
            "text": "To explore the code repository it is best if you install the  sources as editable . This means you can use the application as if it were installed normally but you can change the code and experiment.",
            "title": "Explore the repository"
        },
        {
            "location": "/implementation/explore/#playpy",
            "text": "Start exploring here   The overall plot of the Mau Mau story can be found here. This is the entry point for starting to explore the actual application. It is written in an  imperative  way (like a series of commands given to the computer). The code looks like a series of instructions which are to be carried out in a top down order, descending into the functions being called. The order can be influenced by loops ( for ... in  or  while ) and conditioned branches ( if ... then ... else ). These are the basic control flow constructs Python has. There are a few more, but not many.  Behold! The whole program in 6 lines!  def play_game(gameRules, playerSeed):\n    game = setup_game(gameRules, playerSeed)\n    while not game.over:\n        player = game.next_turn()\n        player.play(game.table)\n    return game  This is the meat of the simulation. Here is where all the magic happens. if you call this function a game of Mau Mau will be simulated and a winner is determined.  6 lines of code  including the function header and the return statement. You now have read the whole plot of the fascinating Mau Mau story. If you want to understand more, you can start digging deeper and visit the definitions of the  functions  and  classes  used in the  play_game  function. Just start to explore the code and how the objects interact in whatever non-linear way you might prefer. This gives you an idea of how a simulation of a simple turn based card game can be implemented as a program.",
            "title": "play.py"
        },
        {
            "location": "/implementation/explore/#modules-defining-the-classes",
            "text": "These look pretty different from  game.py  and they are. Here is where the object oriented part of the story kicks in. If  game.py  contains the plot, these modules contain the descriptions of the actors and props of the story. They describe the relevant part of the virtual universe that is created to run the simulation. It contains custom data structures (a.k.a. classes) to model the problem of simulating Mau Mau. You should be able to read through the classes and get an idea of what elements are needed to simulate a card game and how they might interact.",
            "title": "Modules defining the classes"
        },
        {
            "location": "/implementation/explore/#conceptspy",
            "text": "Classes that stand conceptually above the objects and subjects.",
            "title": "concepts.py"
        },
        {
            "location": "/implementation/explore/#objectspy-and-subjectspy",
            "text": "I know .. in Python everything is an object, so this would be meaningless. This is also not  subject oriented programming . These are just good terms for what those classes describe in the context of the program: there are objects in the game which are manipulated by the subjects.",
            "title": "objects.py and subjects.py"
        },
        {
            "location": "/implementation/explore/#rulespy",
            "text": "This contains the classes that implement the rules of Mau Mau. Start reading with the  MauMau  class and see if you can figure out how it works. There is always one concrete rule active on the table that is valid for the currently played round. Sometimes information gets transferred from one rule to the next (e.g. if a 7 was put on a 7, the number of draws have to accumulate).",
            "title": "rules.py"
        },
        {
            "location": "/implementation/explore/#strategiespy-how-to-play",
            "text": "Classes that implement different player behaviours.   Note  A player has a strategy, but the player also attaches it to the active rule, so that it can be queried for the wanted suit if a Jack is on the table.",
            "title": "strategies.py: How to play"
        },
        {
            "location": "/implementation/explore/#basicstrategy",
            "text": "Player plays according to the rules and always chooses random antidotes if they have any (e.g. 7 on 7 to prevent having to draw) or normal cards. If playing a Jack it always asks for the suit it has the most of.  This can be extended upon to implement \"real\" strategies.",
            "title": "BasicStrategy"
        },
        {
            "location": "/implementation/explore/#humanstrategy",
            "text": "Mainly to show that the existing design makes it very easy to even add interactivity to let a human play against a computer ( mau-mau human ).  The impact of this is very likely to be zero on a planetary basis, as this is just a learning tool, but in general one should be very wary of implementing something just because it's easy:   I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.  -- Tony Hoare   ... you have been warned.",
            "title": "HumanStrategy"
        },
        {
            "location": "/implementation/explore/#statisticspy-create-statistics",
            "text": "Contains functions to run the game simulations and collect statistics. See  usage examples",
            "title": "statistics.py: Create statistics"
        },
        {
            "location": "/implementation/explore/#clipy-command-line-access",
            "text": "This contains the code for the command line interface. Its function  main  is configured in  setup.py   entry_points  to act like a program called  mau-mau  that is accessible where the package is installed.",
            "title": "cli.py: Command line access"
        },
        {
            "location": "/implementation/explore/#peripherals",
            "text": "Note  These files are not part of the actual software but are still vital for helping with development, installation, testing, etc. -- this makes all that tedious stuff you need when writing software less ... tedious.",
            "title": "Peripherals"
        },
        {
            "location": "/implementation/explore/#setuppy-make-program-installable",
            "text": "This module is what is being called, when the package is installed via pip or with  python3 setup.py . This is the standard way of doing it in the Python ecosystem and it is documented  here .",
            "title": "setup.py: Make program installable"
        },
        {
            "location": "/implementation/explore/#toxini-developer-task-automation",
            "text": "This  INI  file configures tasks that can run with the tox commands. The primary goal of tox is to automate testing and act as a frontend for CI, but it can be used for automating other developer tasks as well. See also  the developer documentation  for this tox.ini.",
            "title": "tox.ini: Developer task automation"
        },
        {
            "location": "/implementation/explore/#travisyml-and-appveyoryml-ci-for-different-versions-and-osses",
            "text": "See  documentation about CI",
            "title": ".travis.yml and appveyor.yml: CI for different versions and osses"
        },
        {
            "location": "/implementation/explore/#mkdocsyml-documentation-configuration",
            "text": "See the  documentation for the documentation  (I'm not kidding ...).",
            "title": "mkdocs.yml: Documentation configuration"
        },
        {
            "location": "/implementation/explore/#vagrantfile",
            "text": "To start a VirtualBox with Linux or Windows prepared for development.",
            "title": "Vagrantfile"
        },
        {
            "location": "/dev/getting-started/",
            "text": "Getting started\n\u00b6\n\n\n\n\nNote\n\n\nPlease replace \n</path/to/your/clone>\n with the actual path of your mau-mau repository clone on your computer.\n\n\n\n\nTo work on the code:\n\n\n\n\nFork\n the repository\n\n\nClone\n the repository to \n<path/to/your/clone>\n (wherever that is).\n\n\n\n\n... and install the code as editable in a \nvirtualenv\n:\n\n\n$ <activate your virtualenv>\n$ cd <path/to/your/clone>\n$ pip install -e '.[all]'\n\n\n\nThe output looks like:\n\n\nObtaining file:///</path/to/your/clone>\nInstalling collected packages: mau-mau\n  Running setup.py develop for mau-mau\nSuccessfully installed mau-mau\n\n\n\nMake sure it is installed as editable:\n\n\n$ pip freeze\n\n\n\nThe output looks like (most packages removed from list):\n\n\n[...]\n-e git+git@github.com:obestwalter/mau-mau.git@e4031a17a5e08551317a321d7e74f9ca3b33e0b1#egg=mau_mau\n[...]\nwin-unicode-console==0.4\n\n\n\nThe line starting with the \n-e\n indicates that mau-mau is installed as editable from github.\n\n\nUsing vagrant\n\u00b6\n\n\n\n\nTodo\n\n\nWrite about use of vagrant",
            "title": "Getting started"
        },
        {
            "location": "/dev/getting-started/#getting-started",
            "text": "Note  Please replace  </path/to/your/clone>  with the actual path of your mau-mau repository clone on your computer.   To work on the code:   Fork  the repository  Clone  the repository to  <path/to/your/clone>  (wherever that is).   ... and install the code as editable in a  virtualenv :  $ <activate your virtualenv>\n$ cd <path/to/your/clone>\n$ pip install -e '.[all]'  The output looks like:  Obtaining file:///</path/to/your/clone>\nInstalling collected packages: mau-mau\n  Running setup.py develop for mau-mau\nSuccessfully installed mau-mau  Make sure it is installed as editable:  $ pip freeze  The output looks like (most packages removed from list):  [...]\n-e git+git@github.com:obestwalter/mau-mau.git@e4031a17a5e08551317a321d7e74f9ca3b33e0b1#egg=mau_mau\n[...]\nwin-unicode-console==0.4  The line starting with the  -e  indicates that mau-mau is installed as editable from github.",
            "title": "Getting started"
        },
        {
            "location": "/dev/getting-started/#using-vagrant",
            "text": "Todo  Write about use of vagrant",
            "title": "Using vagrant"
        },
        {
            "location": "/dev/static-analysis/",
            "text": "Static code analysis\n\u00b6\n\n\nFlake8\n\u00b6\n\n\nFlake8\n is a collection of tools that analyze the code without running it. This can be understood as a first line of defense and you learn about style and complexity problems you might have in your code.\n\n\nRun flake8 analysis:\n\n\n$ cd <path/to/your/clone>\n$ flake8 mau_mau/ tests/ --show-source\n\n\n\nIf flake8 is happy it won't produce any output. If not, it looks ike this:\n\n\nmau_mau/cli.py:39:80: E501 line too long (84 > 79 characters)\n####################################################################################\n                                                                               ^\nmau_mau/cli.py:41:1: E302 expected 2 blank lines, found 1\ndef simple_parse_args(argv):\n^\n\n\n\nQuantified Code \n\u00b6\n\n\nQuantified Code offers static code analysis as a webservice that connects to your Github repository. It is an interesting new approach and can teach you a lot about the code you write. It is not just pointing out problems, it tries to educate about the reasoning behind them and even helps to fix the problems. Definitely \nworth a look\n.",
            "title": "Static code analysis"
        },
        {
            "location": "/dev/static-analysis/#static-code-analysis",
            "text": "",
            "title": "Static code analysis"
        },
        {
            "location": "/dev/static-analysis/#flake8",
            "text": "Flake8  is a collection of tools that analyze the code without running it. This can be understood as a first line of defense and you learn about style and complexity problems you might have in your code.  Run flake8 analysis:  $ cd <path/to/your/clone>\n$ flake8 mau_mau/ tests/ --show-source  If flake8 is happy it won't produce any output. If not, it looks ike this:  mau_mau/cli.py:39:80: E501 line too long (84 > 79 characters)\n####################################################################################\n                                                                               ^\nmau_mau/cli.py:41:1: E302 expected 2 blank lines, found 1\ndef simple_parse_args(argv):\n^",
            "title": "Flake8"
        },
        {
            "location": "/dev/static-analysis/#quantified-code",
            "text": "Quantified Code offers static code analysis as a webservice that connects to your Github repository. It is an interesting new approach and can teach you a lot about the code you write. It is not just pointing out problems, it tries to educate about the reasoning behind them and even helps to fix the problems. Definitely  worth a look .",
            "title": "Quantified Code"
        },
        {
            "location": "/dev/tests/",
            "text": "Automatic tests\n\u00b6\n\n\npy.test\n is my tool of choice. There is also a \nstandard library solution\n, which has too much API overhead for my taste. py.test does some very \nclever things\n to let you use the assertion statement directly and you get much better failure reports. This makes for much cleaner test code and less painful testing.\n\n\n\n\nNote\n\n\nThe sources of the test modules are here: \ntests/\n\n\n\n\nThe ability to write simple functions to test your code cannot be developed early enough, so why not start this right away as well? The examples are dead simple and not covering much yet, but show that it's not rocket science to write automatic tests for your code. Pytest makes it possible to use the inbuilt \nassert\n for writing tests.\n\n\npy.test (command line)\n\u00b6\n\n\npy.test looks for modules with the pattern \ntest_*.py\n downwards from your \ncwd\n. In those modules it looks for \ndef test_*\n and \nclass Test*\n. After collecting everything fitting those patterns it execute all test functions and reports back.\n\n\n$ cd </path/to/your/clone>\n$ py.test\n\n\n\nExample for a successful run:\n\n\n========================== test session starts ==========================\nplatform linux -- Python 3.4.3, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir: </path/to/your/clone>, inifile: tox.ini\ncollected 13 items \ntests/test_pile.py .....\ntests/test_player.py ...\ntests/test_sim.py .....\n======================= 13 passed in 0.03 seconds =======================\n\n\n\nExample for a not so successful run:\n\n\n======================= test session starts =============================\nplatform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir: </path/to/your/clone>, inifile: tox.ini\ncollected 35 items\n\ntests/test_concepts.py ...................\ntests/test_objects.py ..F..\ntests/test_player.py ...\ntests/test_rules.py ...\ntests/test_sim.py .....\n======================== short test summary info ========================\nFAIL tests/test_objects.py::test_non_empty_stock\n\n=============================== FAILURES ================================\n_________________________ test_non_empty_stock __________________________\n\n    def test_non_empty_stock():\n>       assert not Stock([0])\nE       assert not Stock([0])\nE        +  where Stock([0]) = Stock([0])\n\ntests/test_objects.py:17: AssertionError\n==================== 1 failed, 34 passed in 0.21 seconds ================\n\n\n\nThis test failed not because the code is broken, but because I made a wrong assertion about the behaviour of the \nStock\n class. If you pass a list when you create the class (like \nStock([Card('Queen', '\u2660'), Card('10', '\u2660')])\n), you should not expect it to be empty afterwards.\n\n\nAutomatically run tests on changes:\n\u00b6\n\n\nIf you want to take this one step further and have the tests being run automatically every time the code changes, you can:\n\n\n$ pip install pytest-watch\n$ cd </path/to/your/clone>\n$ ptw --onfail 'notify-send --urgency=critical \"FAIL\"' --onpass 'notify-send \"PASSED\"'\n\n\n\nnotify-send\n is how I can send desktop notifications from the commandline in my os (\nLinux\n). There are lots of ways to do this on every os - even \nWindows\n and \nMac\n.\n\n\npy.test (PyCharm)\n\u00b6\n\n\nPreparation\n\u00b6\n\n\nThe default testrunner in PyCharm is Unittest. You have to switch to py.test like so:\n\n \nFind Action: \ndefault testrunner\n: set to py.test\n\n accept offer to install it in your project virtualenv or do it yourself with \npip install pytest\n\n\nRunning tests\n\u00b6\n\n\nDepending on where you are, you can run all tests or a part of them. The magic action is \nrun context configuration\n. It runs what is sensible in the context. If your focus is in a normal script it runs the script and if the focus is in a module defining tests it will run the configured testrunner with the tests. Running the context configuration with ...\n\n\n\n\nFocus in the editor, inside a specific test\n\n\nFocus in the editor on the line defining a class containing tests\n\n\nFocus in the \nProject Tool Window\n, choose the \ntests/\n folder and\n\n\n\n\n... all yields different results as which tests are run (and they are what you would intuitively expect).\n\n\nDoctests\n\u00b6\n\n\nYou can write simple examples that can double as tests directly in documentation strings. They are called \ndoctests\n. You can \nrun them directly from PyCharm\n as well.\n\n\nFor an example in the code see \nconcepts.py",
            "title": "Automatic tests"
        },
        {
            "location": "/dev/tests/#automatic-tests",
            "text": "py.test  is my tool of choice. There is also a  standard library solution , which has too much API overhead for my taste. py.test does some very  clever things  to let you use the assertion statement directly and you get much better failure reports. This makes for much cleaner test code and less painful testing.   Note  The sources of the test modules are here:  tests/   The ability to write simple functions to test your code cannot be developed early enough, so why not start this right away as well? The examples are dead simple and not covering much yet, but show that it's not rocket science to write automatic tests for your code. Pytest makes it possible to use the inbuilt  assert  for writing tests.",
            "title": "Automatic tests"
        },
        {
            "location": "/dev/tests/#pytest-command-line",
            "text": "py.test looks for modules with the pattern  test_*.py  downwards from your  cwd . In those modules it looks for  def test_*  and  class Test* . After collecting everything fitting those patterns it execute all test functions and reports back.  $ cd </path/to/your/clone>\n$ py.test  Example for a successful run:  ========================== test session starts ==========================\nplatform linux -- Python 3.4.3, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir: </path/to/your/clone>, inifile: tox.ini\ncollected 13 items \ntests/test_pile.py .....\ntests/test_player.py ...\ntests/test_sim.py .....\n======================= 13 passed in 0.03 seconds =======================  Example for a not so successful run:  ======================= test session starts =============================\nplatform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir: </path/to/your/clone>, inifile: tox.ini\ncollected 35 items\n\ntests/test_concepts.py ...................\ntests/test_objects.py ..F..\ntests/test_player.py ...\ntests/test_rules.py ...\ntests/test_sim.py .....\n======================== short test summary info ========================\nFAIL tests/test_objects.py::test_non_empty_stock\n\n=============================== FAILURES ================================\n_________________________ test_non_empty_stock __________________________\n\n    def test_non_empty_stock():\n>       assert not Stock([0])\nE       assert not Stock([0])\nE        +  where Stock([0]) = Stock([0])\n\ntests/test_objects.py:17: AssertionError\n==================== 1 failed, 34 passed in 0.21 seconds ================  This test failed not because the code is broken, but because I made a wrong assertion about the behaviour of the  Stock  class. If you pass a list when you create the class (like  Stock([Card('Queen', '\u2660'), Card('10', '\u2660')]) ), you should not expect it to be empty afterwards.",
            "title": "py.test (command line)"
        },
        {
            "location": "/dev/tests/#automatically-run-tests-on-changes",
            "text": "If you want to take this one step further and have the tests being run automatically every time the code changes, you can:  $ pip install pytest-watch\n$ cd </path/to/your/clone>\n$ ptw --onfail 'notify-send --urgency=critical \"FAIL\"' --onpass 'notify-send \"PASSED\"'  notify-send  is how I can send desktop notifications from the commandline in my os ( Linux ). There are lots of ways to do this on every os - even  Windows  and  Mac .",
            "title": "Automatically run tests on changes:"
        },
        {
            "location": "/dev/tests/#pytest-pycharm",
            "text": "",
            "title": "py.test (PyCharm)"
        },
        {
            "location": "/dev/tests/#preparation",
            "text": "The default testrunner in PyCharm is Unittest. You have to switch to py.test like so:   Find Action:  default testrunner : set to py.test  accept offer to install it in your project virtualenv or do it yourself with  pip install pytest",
            "title": "Preparation"
        },
        {
            "location": "/dev/tests/#running-tests",
            "text": "Depending on where you are, you can run all tests or a part of them. The magic action is  run context configuration . It runs what is sensible in the context. If your focus is in a normal script it runs the script and if the focus is in a module defining tests it will run the configured testrunner with the tests. Running the context configuration with ...   Focus in the editor, inside a specific test  Focus in the editor on the line defining a class containing tests  Focus in the  Project Tool Window , choose the  tests/  folder and   ... all yields different results as which tests are run (and they are what you would intuitively expect).",
            "title": "Running tests"
        },
        {
            "location": "/dev/tests/#doctests",
            "text": "You can write simple examples that can double as tests directly in documentation strings. They are called  doctests . You can  run them directly from PyCharm  as well.  For an example in the code see  concepts.py",
            "title": "Doctests"
        },
        {
            "location": "/dev/tox/",
            "text": "Tox - a developer frontend\n\u00b6\n\n\nTox\n is one abstraction level up from py.test and serves as a command line frontend for different kinds of tests and also acts a a frontend for external test runners as part of \nCI\n. It automatically creates an environment for the tests, installs dependencies, does whatever else is needed for test preparation and outputs the results.\n\n\nIt can also be (ab)used to act as a frontend for other tasks developers have to do as part of their work. In this project we also use it for building and developing the documentation.\n\n\nRun static code analysis:\n\n\n$ cd </path/to/your/clone>\n$ tox -e static\n\n\n\nThe output is like: \n\n\nstatic create: </path/to/your/clone>/.tox/static\nstatic installdeps: flake8\nstatic develop-inst: </path/to/your/clone>\nstatic installed: flake8==2.5.4,-e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,mccabe==0.4.0,pep8==1.7.0,pyflakes==1.0.0\nstatic runtests: PYTHONHASHSEED='3703953266'\nstatic runtests: commands[0] | flake8 </path/to/your/clone>/mau_mau </path/to/your/clone>/tests --show-source\n\n\n\nCommand line usage:\n\n\n$ cd </path/to/your/clone>\n$ tox -e tests\n\n\n\nThe output is like: \n\n\ntests develop-inst-nodeps: </path/to/your/clone>\ntests installed: -e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,py==1.4.31,pytest==2.9.1\ntests runtests: PYTHONHASHSEED='2804594378'\ntests runtests: commands[0] | py.test </path/to/your/clone>/tests\n============================= test session starts =============================\nplatform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir: </path/to/your/clone>, inifile: tox.ini\ncollected 35 items\n\ntests/test_concepts.py ...................\ntests/test_objects.py .....\ntests/test_player.py ...\ntests/test_rules.py ...\ntests/test_sim.py .....\n\n========================== 35 passed in 0.04 seconds ==========================\n___________________________________ summary ___________________________________\n  tests: commands succeeded\n  congratulations :)\n\n\n\nThis is a very simple setup. There are many more \nconfiguration options\n\n\n\n\nNote\n\n\nJust running \ntox\n without parameters runs all the environments defined in envlist.",
            "title": "Using Tox"
        },
        {
            "location": "/dev/tox/#tox-a-developer-frontend",
            "text": "Tox  is one abstraction level up from py.test and serves as a command line frontend for different kinds of tests and also acts a a frontend for external test runners as part of  CI . It automatically creates an environment for the tests, installs dependencies, does whatever else is needed for test preparation and outputs the results.  It can also be (ab)used to act as a frontend for other tasks developers have to do as part of their work. In this project we also use it for building and developing the documentation.  Run static code analysis:  $ cd </path/to/your/clone>\n$ tox -e static  The output is like:   static create: </path/to/your/clone>/.tox/static\nstatic installdeps: flake8\nstatic develop-inst: </path/to/your/clone>\nstatic installed: flake8==2.5.4,-e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,mccabe==0.4.0,pep8==1.7.0,pyflakes==1.0.0\nstatic runtests: PYTHONHASHSEED='3703953266'\nstatic runtests: commands[0] | flake8 </path/to/your/clone>/mau_mau </path/to/your/clone>/tests --show-source  Command line usage:  $ cd </path/to/your/clone>\n$ tox -e tests  The output is like:   tests develop-inst-nodeps: </path/to/your/clone>\ntests installed: -e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,py==1.4.31,pytest==2.9.1\ntests runtests: PYTHONHASHSEED='2804594378'\ntests runtests: commands[0] | py.test </path/to/your/clone>/tests\n============================= test session starts =============================\nplatform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir: </path/to/your/clone>, inifile: tox.ini\ncollected 35 items\n\ntests/test_concepts.py ...................\ntests/test_objects.py .....\ntests/test_player.py ...\ntests/test_rules.py ...\ntests/test_sim.py .....\n\n========================== 35 passed in 0.04 seconds ==========================\n___________________________________ summary ___________________________________\n  tests: commands succeeded\n  congratulations :)  This is a very simple setup. There are many more  configuration options   Note  Just running  tox  without parameters runs all the environments defined in envlist.",
            "title": "Tox - a developer frontend"
        },
        {
            "location": "/dev/ci/",
            "text": "Continuous integration\n\u00b6\n\n\nTravis CI\n\u00b6\n\n\nTravis CI\n is a webservice that connects to your Github account and runs your tests for you. The configuration is in \n.travis.yml\n (\nYAML\n format).\n\n\nAs we're using tox already the integration with ci is very simple: just install and run \ntox\n on the build machine and we're done.\n\n\nThe badge on top of the projects \nREADME.md\n shows the \nbuild status from Travis CI\n.\n\n\nThis is a very simple setup. There are many more \nconfiguration options\n.\n\n\nAppveyor\n\u00b6\n\n\nAppveyor\n is the pendant to run tests on Windows osses.\n\n\nThe same as for Travis Ci applies to appveyor. The configuration is slightly different but the principle is the same: \n.appveyor.yml\n (\nYAML\n format)\n\n\nThe badge on top of the projects \nREADME.md\n shows the \nbuild status from Travis CI\n.",
            "title": "Continuous intergration"
        },
        {
            "location": "/dev/ci/#continuous-integration",
            "text": "",
            "title": "Continuous integration"
        },
        {
            "location": "/dev/ci/#travis-ci",
            "text": "Travis CI  is a webservice that connects to your Github account and runs your tests for you. The configuration is in  .travis.yml  ( YAML  format).  As we're using tox already the integration with ci is very simple: just install and run  tox  on the build machine and we're done.  The badge on top of the projects  README.md  shows the  build status from Travis CI .  This is a very simple setup. There are many more  configuration options .",
            "title": "Travis CI"
        },
        {
            "location": "/dev/ci/#appveyor",
            "text": "Appveyor  is the pendant to run tests on Windows osses.  The same as for Travis Ci applies to appveyor. The configuration is slightly different but the principle is the same:  .appveyor.yml  ( YAML  format)  The badge on top of the projects  README.md  shows the  build status from Travis CI .",
            "title": "Appveyor"
        },
        {
            "location": "/dev/docs/",
            "text": "Documentation building and hosting\n\u00b6\n\n\nMkDocs and Github pages\n\u00b6\n\n\nMkDocs\n\u00b6\n\n\nThe documentation is generated with \nMkDocs\n and it lives in \ndocs/\n. The configuration is in \nmkdocs.yml\n (\nYAML\n format).\n\n\nMarkdown\n is an easy to learn format that is the default on \nGithub\n and \nStack Overflow\n. It is much easier on the eye than restructuredText - the established standard in the Python world. But it is also not as powerful. For more complex documentation \nSphinx\n and \nrestructuredText\n might be better suited.\n\n\nGithub pages\n\u00b6\n\n\nGithub offers the option to host the project documentation on \nGithub Pages\n. MkDocs has an inbuilt deploy functionality to push the documentation there. The pages are hosted as project homepage on \ngithub.io\n.\n\n\nWorking on the documentation\n\u00b6\n\n\nWhen you work on the documentation you can start a local server:\n\n\n$ cd <path/to/your/clone>\n$ tox -e docs-auto\n\n\n\nThis prepares an environment and runs \nmkdocs serve\n. You can do it directly already. Using tox here is a bit of overkill, but serves to demonstrate that you can use tox for automating and standardising all kinds of development tasks.\n\n\nThe documentation is now served on \nlocalhost:8000\n and changes are automatically detected and the website is reloaded.\n\n\nTidy up the build in case of big changes or problems:\n\n\n$ tox -e docs-clean\n\n\n\nDeploying the documentation\n\u00b6\n\n\nIf you have push rights for the repository, you can deploy the current documentation with:\n\n\n$ cd <path/to/your/clone>\n$ tox -e docs-deploy",
            "title": "Working on documentation"
        },
        {
            "location": "/dev/docs/#documentation-building-and-hosting",
            "text": "",
            "title": "Documentation building and hosting"
        },
        {
            "location": "/dev/docs/#mkdocs-and-github-pages",
            "text": "",
            "title": "MkDocs and Github pages"
        },
        {
            "location": "/dev/docs/#mkdocs",
            "text": "The documentation is generated with  MkDocs  and it lives in  docs/ . The configuration is in  mkdocs.yml  ( YAML  format).  Markdown  is an easy to learn format that is the default on  Github  and  Stack Overflow . It is much easier on the eye than restructuredText - the established standard in the Python world. But it is also not as powerful. For more complex documentation  Sphinx  and  restructuredText  might be better suited.",
            "title": "MkDocs"
        },
        {
            "location": "/dev/docs/#github-pages",
            "text": "Github offers the option to host the project documentation on  Github Pages . MkDocs has an inbuilt deploy functionality to push the documentation there. The pages are hosted as project homepage on  github.io .",
            "title": "Github pages"
        },
        {
            "location": "/dev/docs/#working-on-the-documentation",
            "text": "When you work on the documentation you can start a local server:  $ cd <path/to/your/clone>\n$ tox -e docs-auto  This prepares an environment and runs  mkdocs serve . You can do it directly already. Using tox here is a bit of overkill, but serves to demonstrate that you can use tox for automating and standardising all kinds of development tasks.  The documentation is now served on  localhost:8000  and changes are automatically detected and the website is reloaded.  Tidy up the build in case of big changes or problems:  $ tox -e docs-clean",
            "title": "Working on the documentation"
        },
        {
            "location": "/dev/docs/#deploying-the-documentation",
            "text": "If you have push rights for the repository, you can deploy the current documentation with:  $ cd <path/to/your/clone>\n$ tox -e docs-deploy",
            "title": "Deploying the documentation"
        },
        {
            "location": "/acknowledgements/",
            "text": "Acknowledgements\n\u00b6\n\n\nThanks to the \nCodeCats\n and the \nZeppelin University\n for giving me the chance to assist motivated students in learning to program.\n\n\nThe logo is a \nc64-ified\n version of \na playing card by Cobey Pile\n.\n\n\nProgramming, template and markup languages\n\u00b6\n\n\n\n\nPython\n\n\nJavascript\n\n\nHTML\n\n\nCSS\n\n\nMarkdown\n\n\nini\n\n\nYAML\n\n\nJinja2\n\n\n\n\nTools\n\u00b6\n\n\n\n\nIDE: \nPyCharm\n\n\nAutomatic tests: \npytest\n\n\nStatic code analysis: \nFlake8\n\n\nSource control: \ngit\n\n\nCode collaboration: \ngithub\n\n\nDeveloper task automation: \nTox\n\n\nDocumentation: \nMkDocs\n with \nmaterial theme\n\n\nAutomatic version handling: \nSetuptools SCM\n\n\nContinuous Integration on Linux \nTravis CI\n\n\nContinuous Integration on Windows \nAppveyor\n\n\nStatic code analysis as a service: \nquantifiedcode\n\n\nMarkdown editing: \nPycharm Markdown Navigator\n\n\nGenerating diagrams: \nGliffy\n\n\n\n\nOperating systems\n\u00b6\n\n\n\n\nUbuntu Linux\n\n\nMicrosoft Windows 10",
            "title": "Acknowlegements"
        },
        {
            "location": "/acknowledgements/#acknowledgements",
            "text": "Thanks to the  CodeCats  and the  Zeppelin University  for giving me the chance to assist motivated students in learning to program.  The logo is a  c64-ified  version of  a playing card by Cobey Pile .",
            "title": "Acknowledgements"
        },
        {
            "location": "/acknowledgements/#programming-template-and-markup-languages",
            "text": "Python  Javascript  HTML  CSS  Markdown  ini  YAML  Jinja2",
            "title": "Programming, template and markup languages"
        },
        {
            "location": "/acknowledgements/#tools",
            "text": "IDE:  PyCharm  Automatic tests:  pytest  Static code analysis:  Flake8  Source control:  git  Code collaboration:  github  Developer task automation:  Tox  Documentation:  MkDocs  with  material theme  Automatic version handling:  Setuptools SCM  Continuous Integration on Linux  Travis CI  Continuous Integration on Windows  Appveyor  Static code analysis as a service:  quantifiedcode  Markdown editing:  Pycharm Markdown Navigator  Generating diagrams:  Gliffy",
            "title": "Tools"
        },
        {
            "location": "/acknowledgements/#operating-systems",
            "text": "Ubuntu Linux  Microsoft Windows 10",
            "title": "Operating systems"
        }
    ]
}